@page "/simulations/results"
@implements IDisposable
@inject ISimulationBatchService SimulationBatchService
@rendermode InteractiveServer

<PageTitle>Simulation Results</PageTitle>

<div class="page-header">
    <h1>Simulation Results</h1>
    <a href="/simulations/run" class="btn btn-primary">Run new batch</a>
</div>

@if (_hasActiveBatches && _hasLoadedOnce)
{
    <RefreshIndicator
        LastUpdated="_lastUpdated"
        IsPaused="_refreshPaused"
        IsRefreshing="_backgroundRefreshInProgress"
        IntervalSeconds="5"
        OnRefresh="ManualRefreshAsync"
        OnPauseToggle="TogglePauseAsync" />
}

@if (!string.IsNullOrEmpty(_error))
{
    <Alert Message="@_error" Severity="AlertSeverity.Error" />
}

<div class="batches-filters card">
    <h3 class="card__title">Filters</h3>
    <div class="card__body batches-filters__row">
        <div class="batches-filters__field">
            <label for="status-filter">Status</label>
            <select id="status-filter" @bind="_statusFilter" class="form-select">
                <option value="">All statuses</option>
                <option value="Pending">Pending</option>
                <option value="Running">Running</option>
                <option value="Completed">Completed</option>
                <option value="Error">Error</option>
            </select>
        </div>
        <div class="batches-filters__field">
            <label for="event-search">Event name</label>
            <input id="event-search" type="text" @bind="_eventNameSearch" placeholder="Search by event name" class="form-input" />
        </div>
        <div class="batches-filters__actions">
            <button type="button" class="btn btn-outline" @onclick="ApplyFiltersAsync" disabled="@_refreshing">Apply</button>
            @if (_refreshing)
            {
                <LoadingSpinner Inline="true" Label="Applying filters…" />
            }
        </div>
    </div>
</div>

@if (!_hasLoadedOnce)
{
    <LoadingSpinner Label="Loading batches…" />
}
else if (_items.Count == 0)
{
    <div class="empty-state">
        <p>No batches found.</p>
        <p>Run a simulation to see results here.</p>
        <a href="/simulations/run" class="btn btn-primary" style="margin-top: 1rem;">Run Simulations</a>
    </div>
}
else
{
    <div class="table-container">
        <table class="data-table">
            <thead>
                <tr>
                    <th>Batch</th>
                    <th>Created</th>
                    <th>Status</th>
                    <th>Event</th>
                    <th>Runs</th>
                    <th>Completed</th>
                    <th>Failed</th>
                    <th>Seed</th>
                    <th>Mode</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var row in _items)
                {
                    <tr @key="row.BatchId">
                        <td><a href="/simulations/results/@row.BatchId">@row.BatchId.ToString("N")[..8]…</a></td>
                        <td>@row.CreatedAt.ToString("g")</td>
                        <td>@row.Status</td>
                        <td>@(string.IsNullOrEmpty(row.EventName) ? "(Unknown event)" : row.EventName)</td>
                        <td>@row.RunCount</td>
                        <td>@row.CompletedCount</td>
                        <td>@row.FailedCount</td>
                        <td>@(row.Seed.Length > 12 ? row.Seed[..12] + "…" : row.Seed)</td>
                        <td>@(row.ExecutionMode?.ToString() ?? "—")</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
    <p class="text-muted">Showing up to @_items.Count batch(es).</p>
}

@code {
    private const int RefreshIntervalSeconds = 5;

    private List<BatchListRowDto> _items = [];
    private bool _hasLoadedOnce;
    private bool _refreshing;
    private bool _backgroundRefreshInProgress;
    private bool _refreshPaused;
    private DateTimeOffset? _lastUpdated;
    private string? _error;
    private string _statusFilter = "";
    private string _eventNameSearch = "";
    private bool _hasActiveBatches;
    private System.Threading.Timer? _refreshTimer;

    protected override async Task OnInitializedAsync()
    {
        await LoadBatchesAsync(isBackgroundRefresh: false);
    }

    public void Dispose()
    {
        _refreshTimer?.Dispose();
    }

    private Task ApplyFiltersAsync() => LoadBatchesAsync(isBackgroundRefresh: false);

    private async Task ManualRefreshAsync()
    {
        if (_backgroundRefreshInProgress) return;
        await LoadBatchesAsync(isBackgroundRefresh: true);
    }

    private async Task TogglePauseAsync()
    {
        _refreshPaused = !_refreshPaused;
        if (_refreshPaused)
        {
            _refreshTimer?.Dispose();
            _refreshTimer = null;
        }
        else if (_hasActiveBatches)
        {
            StartTimer();
        }
        await InvokeAsync(StateHasChanged);
    }

    private void StartTimer()
    {
        _refreshTimer?.Dispose();
        _refreshTimer = new System.Threading.Timer(_ => InvokeAsync(TimerTickAsync).GetAwaiter().GetResult(), null, RefreshIntervalSeconds * 1000, RefreshIntervalSeconds * 1000);
    }

    private async Task TimerTickAsync()
    {
        if (_refreshPaused || _backgroundRefreshInProgress) return;
        await LoadBatchesAsync(isBackgroundRefresh: true);
    }

    private async Task LoadBatchesAsync(bool isBackgroundRefresh)
    {
        if (isBackgroundRefresh)
        {
            if (_backgroundRefreshInProgress) return;
            _backgroundRefreshInProgress = true;
        }
        else
        {
            if (_hasLoadedOnce)
            {
                _refreshing = true;
            }
            _error = null;
        }
        try
        {
            var request = new ListBatchesRequest
            {
                Top = 50,
                StatusFilter = ParseStatusFilter(_statusFilter),
                EventNameSearch = string.IsNullOrWhiteSpace(_eventNameSearch) ? null : _eventNameSearch.Trim()
            };
            var result = await SimulationBatchService.GetBatchesAsync(request);
            _items = result.Items.ToList();
            _hasLoadedOnce = true;
            _lastUpdated = DateTimeOffset.UtcNow;
            _hasActiveBatches = _items.Any(r => r.Status == BingoSim.Core.Enums.BatchStatus.Running || r.Status == BingoSim.Core.Enums.BatchStatus.Pending);

            if (_hasActiveBatches && !_refreshPaused)
            {
                if (_refreshTimer is null)
                    StartTimer();
            }
            else
            {
                _refreshTimer?.Dispose();
                _refreshTimer = null;
            }
        }
        catch (Exception ex)
        {
            if (!isBackgroundRefresh)
            {
                _error = ex.Message;
            }
        }
        finally
        {
            _refreshing = false;
            _backgroundRefreshInProgress = false;
        }
    }

    private static BingoSim.Core.Enums.BatchStatus? ParseStatusFilter(string value)
    {
        return value?.Trim() switch
        {
            "Pending" => BingoSim.Core.Enums.BatchStatus.Pending,
            "Running" => BingoSim.Core.Enums.BatchStatus.Running,
            "Completed" => BingoSim.Core.Enums.BatchStatus.Completed,
            "Error" => BingoSim.Core.Enums.BatchStatus.Error,
            _ => null
        };
    }
}
