@page "/simulations/results/{BatchId:guid}"
@implements IDisposable
@inject ISimulationBatchService SimulationBatchService
@inject NavigationManager NavigationManager
@rendermode InteractiveServer

<PageTitle>Simulation Results</PageTitle>

<div class="page-header">
    <h1>Simulation Results</h1>
    <a href="/simulations/results" class="btn btn-outline">Back to list</a>
    <a href="/simulations/run" class="btn btn-primary">Run new batch</a>
</div>

@if (_batch is null && !_loading)
{
    <p>Batch not found. <a href="/simulations/results">Back to list</a></p>
}
else if (_batch is null)
{
    <LoadingSpinner Label="Loading batch…" />
}
else
{
    <div class="batch-cards">
        <div class="card">
            <h3 class="card__title">Batch</h3>
            <div class="card__body batch-meta">
                <dl class="batch-meta__grid">
                    <dt>ID</dt>
                    <dd>@_batch.Id.ToString("N")[..8]…</dd>
                    <dt>Runs requested</dt>
                    <dd>@_batch.RunsRequested</dd>
                    <dt>Seed</dt>
                    <dd>@(string.IsNullOrEmpty(_batch.Seed) ? "—" : _batch.Seed)</dd>
                    <dt>Status</dt>
                    <dd>@_batch.Status</dd>
                </dl>
            </div>
            @if (_batch.Status == BingoSim.Core.Enums.BatchStatus.Error && !string.IsNullOrEmpty(_batch.ErrorMessage))
            {
                <Alert Message="@_batch.ErrorMessage" Severity="AlertSeverity.Error" />
            }
        </div>

        <div class="card">
            <h3 class="card__title">Progress</h3>
            <div class="card__body">
                <dl class="progress-counts">
                    <dt>Completed</dt>
                    <dd>@_progress.Completed</dd>
                    <dt>Failed</dt>
                    <dd>@_progress.Failed</dd>
                    <dt>Running</dt>
                    <dd>@_progress.Running</dd>
                    <dt>Pending</dt>
                    <dd>@_progress.Pending</dd>
                    @if (_progress.RetryCount > 0)
                    {
                        <dt>Retries</dt>
                        <dd>@_progress.RetryCount</dd>
                    }
                </dl>
                @if (_progress.ElapsedSeconds > 0 || _progress.RunsPerSecond > 0)
                {
                    <dl class="progress-metrics">
                        <dt>Elapsed</dt>
                        <dd>@_progress.ElapsedSeconds s</dd>
                        @if (_progress.RunsPerSecond > 0)
                        {
                            <dt>Runs/sec</dt>
                            <dd>@_progress.RunsPerSecond.ToString("F1")</dd>
                        }
                    </dl>
                }
                @if (_batch.Status == BingoSim.Core.Enums.BatchStatus.Running || _batch.Status == BingoSim.Core.Enums.BatchStatus.Pending)
                {
                    <div class="progress-bar-wrapper">
                        <span class="progress-bar-label">@(GetProgressPercent().ToString("F0"))% complete</span>
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: @(GetProgressPercent())%"></div>
                        </div>
                    </div>
                    <RefreshIndicator
                LastUpdated="_lastUpdated"
                IsPaused="_refreshPaused"
                IsRefreshing="_backgroundRefreshInProgress"
                IntervalSeconds="3"
                OnRefresh="ManualRefreshAsync"
                OnPauseToggle="TogglePauseAsync" />
                }
            </div>
        </div>
    </div>

    @if (_batch.Status != BingoSim.Core.Enums.BatchStatus.Pending && _batch.Status != BingoSim.Core.Enums.BatchStatus.Running && !string.IsNullOrEmpty(_batch.Seed))
    {
        <div class="form-actions" style="margin-top: 1rem;">
            <button type="button" class="btn btn-outline" @onclick="RerunWithSameSeedAsync">Rerun with same seed</button>
        </div>
    }
    @if (!string.IsNullOrEmpty(_errorMessage))
    {
        <Alert Message="@_errorMessage" Severity="AlertSeverity.Error" />
    }

    @if (_aggregates.Count > 0)
    {
        <h2>Per-team aggregates</h2>
        <div class="table-container">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Team</th>
                        <th>Strategy</th>
                        <th>Winner rate</th>
                        <th>Mean / Min / Max points</th>
                        <th>Mean / Min / Max tiles</th>
                        <th>Mean / Min / Max row</th>
                        <th>Runs</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var a in _aggregates)
                    {
                        <tr @key="a.TeamId">
                            <td>@a.TeamName</td>
                            <td>@a.StrategyKey</td>
                            <td>@(a.WinnerRate.ToString("P1"))</td>
                            <td>@(a.MeanPoints.ToString("F1")) / @a.MinPoints / @a.MaxPoints</td>
                            <td>@(a.MeanTilesCompleted.ToString("F1")) / @a.MinTilesCompleted / @a.MaxTilesCompleted</td>
                            <td>@(a.MeanRowReached.ToString("F1")) / @a.MinRowReached / @a.MaxRowReached</td>
                            <td>@a.RunCount</td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    }

    @if (_sampleRunResults.Count > 0)
    {
        <h2>Sample run timelines (first run)</h2>
        @foreach (var teamResult in _sampleRunResults)
        {
            <details>
                <summary>@teamResult.TeamName — @teamResult.StrategyKey (points: @teamResult.TotalPoints, tiles: @teamResult.TilesCompletedCount, row: @teamResult.RowReached@(teamResult.IsWinner ? ", winner" : ""))</summary>
                <pre class="timeline-json">Row unlock times: @teamResult.RowUnlockTimesJson</pre>
                <pre class="timeline-json">Tile completion times: @teamResult.TileCompletionTimesJson</pre>
            </details>
        }
    }
}

@code {
    [Parameter]
    public Guid BatchId { get; set; }

    private const int RefreshIntervalSeconds = 3;

    private BingoSim.Application.DTOs.SimulationBatchResponse? _batch;
    private BingoSim.Application.DTOs.BatchProgressResponse _progress = new();
    private List<BingoSim.Application.DTOs.BatchTeamAggregateResponse> _aggregates = [];
    private List<BingoSim.Application.DTOs.TeamRunResultResponse> _sampleRunResults = [];
    private bool _loading = true;
    private bool _backgroundRefreshInProgress;
    private bool _refreshPaused;
    private DateTimeOffset? _lastUpdated;
    private string? _errorMessage;
    private Guid _loadedBatchId;
    private System.Threading.Timer? _refreshTimer;

    protected override async Task OnParametersSetAsync()
    {
        if (BatchId != _loadedBatchId)
        {
            _loadedBatchId = BatchId;
            _batch = null;
            _loading = true;
            _refreshPaused = false;
            await LoadAsync(isBackgroundRefresh: false);
        }
    }

    public void Dispose()
    {
        _refreshTimer?.Dispose();
    }

    private async Task ManualRefreshAsync()
    {
        if (_backgroundRefreshInProgress) return;
        await LoadAsync(isBackgroundRefresh: true);
    }

    private async Task TogglePauseAsync()
    {
        _refreshPaused = !_refreshPaused;
        if (_refreshPaused)
        {
            _refreshTimer?.Dispose();
            _refreshTimer = null;
        }
        else if (_batch?.Status == BingoSim.Core.Enums.BatchStatus.Running || _batch?.Status == BingoSim.Core.Enums.BatchStatus.Pending)
        {
            StartTimer();
        }
        await InvokeAsync(StateHasChanged);
    }

    private void StartTimer()
    {
        _refreshTimer?.Dispose();
        _refreshTimer = new System.Threading.Timer(_ => InvokeAsync(TimerTickAsync).GetAwaiter().GetResult(), null, RefreshIntervalSeconds * 1000, RefreshIntervalSeconds * 1000);
    }

    private async Task TimerTickAsync()
    {
        if (_refreshPaused || _backgroundRefreshInProgress) return;
        await LoadAsync(isBackgroundRefresh: true);
    }

    private async Task LoadAsync(bool isBackgroundRefresh)
    {
        if (isBackgroundRefresh)
        {
            if (_backgroundRefreshInProgress) return;
            _backgroundRefreshInProgress = true;
        }

        var batchIdToLoad = BatchId;
        _refreshTimer?.Dispose();
        _refreshTimer = null;

        var batch = await SimulationBatchService.GetBatchByIdAsync(batchIdToLoad);
        if (batchIdToLoad != BatchId)
        {
            _backgroundRefreshInProgress = false;
            return;
        }

        if (batch is null)
        {
            _batch = null;
            _loading = false;
            _backgroundRefreshInProgress = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        _batch = batch;
        _progress = await SimulationBatchService.GetProgressAsync(batchIdToLoad);
        if (batchIdToLoad != BatchId)
        {
            _backgroundRefreshInProgress = false;
            return;
        }

        _aggregates = (await SimulationBatchService.GetBatchAggregatesAsync(batchIdToLoad)).ToList();
        if (batchIdToLoad != BatchId)
        {
            _backgroundRefreshInProgress = false;
            return;
        }

        if (_aggregates.Count > 0 && _aggregates[0].TeamId != default)
        {
            var sample = (await SimulationBatchService.GetBatchRunResultsForTeamAsync(batchIdToLoad, _aggregates[0].TeamId, 1)).ToList();
            if (sample.Count > 0)
            {
                var runId = sample[0].SimulationRunId;
                _sampleRunResults = (await SimulationBatchService.GetRunResultsAsync(runId)).ToList();
            }
        }

        _loading = false;
        _lastUpdated = DateTimeOffset.UtcNow;

        if ((_batch.Status == BingoSim.Core.Enums.BatchStatus.Running || _batch.Status == BingoSim.Core.Enums.BatchStatus.Pending) && !_refreshPaused)
        {
            StartTimer();
        }

        _backgroundRefreshInProgress = false;
        await InvokeAsync(StateHasChanged);
    }

    private double GetProgressPercent()
    {
        var total = _progress.Completed + _progress.Failed + _progress.Running + _progress.Pending;
        if (total == 0) return 0;
        return 100.0 * (_progress.Completed + _progress.Failed) / total;
    }

    private async Task RerunWithSameSeedAsync()
    {
        if (_batch is null) return;
        _errorMessage = null;
        try
        {
            var request = new BingoSim.Application.DTOs.StartSimulationBatchRequest
            {
                EventId = _batch.EventId,
                RunCount = _batch.RunsRequested,
                Seed = _batch.Seed,
                ExecutionMode = _batch.ExecutionMode
            };
            var newBatch = await SimulationBatchService.StartBatchAsync(request);
            NavigationManager.NavigateTo($"/simulations/results/{newBatch.Id}");
        }
        catch (Exception ex)
        {
            _errorMessage = ex.Message;
        }
    }
}
